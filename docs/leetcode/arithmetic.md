## 二进制间距 (http://t.zoukankan.com/derek1184405959-p-14635484.html)

```js
1. 二进制间距

给定一个正整数n,找到并返回 n 的二进制表示中两个相邻 1 之间的最长距离。如果不存在两个相邻的1，返回0。
如果只有0将两个1分隔开（可能不存在0），则认为这两个1彼此相邻。两个1之间的距离是它们的二进制表示中位置的绝对差。例如，“1001”中的两个1的距离为3。

示例1：
  输入： n=22
  输出: 2
  解释：22的二进制是“10110”
  在 22 的二进制表示中，有三个 1，组成两队相邻的 1。
  第一对相邻的 1 中，两个 1 之间的距离为 2。
  第二对相邻的 1 中，两个 1 之间的距离为 1。
  答案取两个距离之中最大的，也就是 2。

示例2：
  输入：n = 8
  输出： 0
  解释： 8 的二进制是“1000”。
  在 8 的二进制表示中没有相邻的两个 1,所以返回 0。

示例3：
  输入：n = 5
  输出： 2
  解释：5 的二进制是“101”。

提示： 1 <= n <= 10^9

方法一：位运算

  思路与算法

  我们可以使用一个循环从 n 二进制表示的低位开始进行遍历，并找出所有的 1。
  我们用一个变量 last 记录上一个找到的 1 的位置。如果当前在第 i 位找到了 1，那么就用 i - last 更新答案，再将 last 更新为 i 即可。

  在循环的每一步中，我们可以使用位运算 n & 1 获取 n 的最低位，判断其是否为 1。在这之后，我们将 n 右移一位： n = n >> 1, 这样在第 i 步时，n & 1 得到的就是初始 n 的第 i 个二进制位。

var binaryGap = function(n) {
    let last = -1, ans = 0;
    for (let i = 0; n != 0; ++i) {
        if ((n & 1) === 1) {
            if (last !== -1) {
                ans = Math.max(ans, i - last);
            }
            last = i;
        }
        n >>= 1;
    }
    return ans;
};

复杂度分析：

`时间复杂度`：O(\log n)O(logn)。循环中的每一步 nn 会减少一半，因此需要 O(\log n)O(logn) 次循环。
`空间复杂度`：O(1)O(1)。
```

**注：**

## 位运算

> 程序中所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中二进制进行操作。比如：and 运算本来就是一个逻辑运算符，但整数与整数之间也可以进行 and 运算。举个栗子，6的二进制是110，11的二进制是1011，那么 6 and 11 的结果就是2，它是二进制对应位进行逻辑运算的结果（0表示 False，1表示 True，空位都当 0 处理）。


## 运算符号

含义 | Pascal 语言 | C语言 | Java | Php             |     运算规则
----- | ---------- | ----- | ---- | ----          |     ---------
按位与 | a and b    | a & b | a & b | a & b        |     相同为的两个数字都为 1，则为1；若有一个不为1，则为0
按位或 | a or b     | a | b | a | b | a | b        |     相同位只要一个为 1 即为 1
按位异或 | a xor b  | a ^ b | a ^ b | a ^ b        |     相同位不同则为1，相同则为0
按位取反 | not a | ~a | ~a | ~a                    |     把内存中的0和1全部取反
左移 | a shl b | a <<b | a <<b | a << b           |     各二进位全部左移若干位，高位丢弃，低位补0  例：1101 1000  左移两位为：01100000
带符号右移 | a shr b | a >> b | a >> b | a >> b    |     各二进位全部右移若干位，低位丢弃，对于有符号数，有的补符号位（算数右移），有的补0（逻辑右移）  例：1101 0101  右移两位为：00110101
无符号右移 | / | / | a>>> b | /                    |     各二进位全部右移若干位，低位丢弃，对于无符号数，高位补0；

**十进制转二进制：**
```
  例如 10：

  10/2  5        0
  5/2   2.5      1
  2/2   1        0
  1/2   0.5      1

  二进制为：1010
```
**二进制转十进制**
```
  例如 1010：

  补位：00001010
  计算：0*2^7 + 0*2^6 + 0*2^5 + 0*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 0*2^0
       0     + 0     + 0     + 0     + 8     + 0     + 2     + 0
  结果：10

  例如 1011.01：

  计算：1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 + 0*2^-1 + 1*2^-2
       8     + 0     + 2     + 1     + 0      + 0.25
  结果：11.25
```

**异或的特点：**
* x^0 = x
* x^1s = ~x。1s 的意思是全为1的二进制数
* x^(~x) = 1s
* x^x = 0
* a^b = c  --> a^c = b, b^c = a。用来交换 a、b 的值。比如，设 a = 1001, b = 1100, 那么 c = a^b = 0101，则 a^c = 1100, b^c = 1001，正好可以交换 a、b 的值。
* a^b^c = a^(b^c) = (a^b)^c

**常用的位运算操作**
* 判断奇偶数：x & 1 == 1为奇数，x & 1 == 0 为偶数
* 清零最低位的 1：x & (x - 1)
* 得到最低位的 1：x & -x。-x 为取反再加1

**更为复杂的位运算操作**
* 将 x 最右边的 n 位清零：x & (~ 0<<n)
* 获取 x 的第 n 位值（0或1）：(x >> n) & 1
* 获取 x 的第 n 位幂值：x & (1 << (n -1))
* 仅将第 n 位置为 1：x | (1 << n)
* 仅将第 n 位置为 0：x & (~(1 << n))
* 将 x 最高位至第 n 位（含）清零：x & ((1 << n)-1)
* 将 x 第 n 位至第 0 位（含）清零：x & (~((1 << (n+1))-1))