# striveDocs

## **arithmetic**
### **介绍** 
  [链接] <https://blog.csdn.net/qq_49613557/article/details/115301174/>
        <https://blog.csdn.net/weixin_45329397/article/details/121308688/>

1. 算法效率
   > 算法效率分析分为两种：第一种是时间效率，第二种是空间效率。时间效率被称为时间复杂度，而空间效率被称为空间复杂度。时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要的额外空间，在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要特别关注一个算法的空间复杂度。
2. 时间复杂度
   > 在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。（我们经常用到 O(1), O(n), O(logn), O(nlogn) 来表示对应算法的时间复杂度。时间复杂度的排序是 O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!) < O(n^n)）

   * 时间复杂度为 O(1)，代码只被执行一次
   * 时间复杂度为 O(n)，比如常见的遍历算法。也就是一个 for 循环的时间复杂度。
   * O(n^2) 就是嵌套 for 循环，就是两个 for 循环，是不是相当于运行了 n*n 次。比如冒泡和选择排序。
   * 再比如 O(logn),（log 是以 2 为底）。二分搜索就是 O(logn) 的算法，每找一次排除一半的可能。
   * O(nlogn) 同理，就是 n 乘以 logn，归并排序就是典型的例子。  

#### **大 O 的渐进表示法**

```
- 实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用大 O 的渐进表示法。
- 大 O 符号（Big O notation）：是用于描述函数渐进行为的数学符号。
- 推导大 O 阶方法：
  1. 用常数 1 取代运行时间中的所有加法常数。
  2. 在修改后的运行次数函数中，只保留最高阶项。
  3. 如果最高阶项存在且不是 1，则去除与这个项目相乘的常数。得到的 结果就是就是大 O 阶。
```

> 大 O 的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。
> 另外有些算法的时间复杂度存在最好、平均和最坏情况：
  * 最坏情况：任意输入规模的最大运行次数（上界）
  * 平均情况：任意输入规模的期望运行次数
  * 最好情况：任务输入规模的最小运行次数（下界）
  [例如：在一个长度为 N  数组中搜索一个数据 x]
  1. 最好情况：1 次找到
  2. 最坏情况：N 次找到
  3. 平均情况：N/2 次找到
  **_在实际在中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为 O(N)_**  **```注：```** 执行 100 次，复杂度为 O(100)即O(1);
执行次数只要是常数项（可以明确知道执行多少次）都是O(1)
  ```js
  例如：计算冒泡时间排序的时间复杂度?

  // 外循环，冒泡的趟数
  // 内循环，具体冒泡的方式--相邻元素进行比较

  时间复杂度计算:

     计算单趟冒泡时间 * 冒泡总趟数 即 O(N) * O(N-1) = O(N(N-1)) = O(N ^ 2)

  例如：计算斐波那契递归的时间复杂度？

      递归总次数 * 单次递归耗费的时间

      单词递归时间为O(1)
      递归总次数：1+2+4+8+...+2^n  约等于 2^n

      时间复杂度为：O(1)*O(2^n) = O(2^n)
  ```

3. 空间复杂度
  > 空间复杂度是一个对算法在运行过程中临时占用存储空间大小的量度。空间复杂度不是程序占用了多少 bytes 的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟实践复杂度类似，也是用 O 渐进表示法。（算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量 n 的大小而改变时，可表示为O(1);当一个算法的空间复杂度与以 2 为底的 n 的对数成正比时，可表示为 O(log2n)；当一个算法的空间复杂度与 n 成线性比例关系时，可表示为O(n).若形参为数组，则只需要为它分配一个存储有实参出攒送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便有系统自动引用实参变量。）

  * O(1) 单个变量所占的空间永远为 1
  * O(n) 数组里面有 n 个值，占用了 n 个内存单元
  * O(n^2) 可以想象为一个正方形，边长为 n，存储了 n 的二次方个变量

  ```
  例如：
  1. 冒泡排序的空间复杂度：使用了常数个额外空间, 为O(1)
  2. 斐波那契的空间复杂度：动态开辟了N 个空间，为O(N)
  3. 阶乘递归的空间复杂度：递归调用了 N 次，开辟了 N 个栈帧，每个栈帧使用了常数个空间。为O(N)
  ```

**如何衡量一个算法的好坏？**
> 复杂度：时间复杂度和空间复杂度——本质：数学表达式——某条基本语句关于问题 N 的数学表达式
> 一般情况下：采用大 O 渐进表示法来表示
  先计算出数学表达式，按照以下规则来进行处理

  * 数学表达式是常量————0(1)
  * 数学表达式有多个表达式构成，取最高阶项
  * 如果最高阶项不为 1，将其系数修改成 1

> 时间复杂度：最优情况、平均情况、最差情况————以最差情况为准